.\" Man page generated from reStructuredText.
.
.TH "PCOCC-CONTAINERS.YAML" "5" "Aug 01, 2019" "0.5.1" "pcocc"
.SH NAME
pcocc-containers.yaml \- Container Configuration File
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH DESCRIPTION
.sp
\fBcontainers.yaml\fP is a YAML formatted file defining container templates that can be instantiated with pcocc. This configuration can be read from several locations. System\-wide definitions are read from \fB/etc/pcocc/containers.yaml\fP while user\-specific templates are read from \fB$HOME/.pcocc/containers.yaml\fP\&. A user has access to both his personal templates and the system\-wide templates.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
The location of user configuration files, by default \fB$HOME/.pcocc\fP can be changed to another directory by setting the  \fBPCOCC_USER_CONF_DIR\fP environment variable.
.UNINDENT
.UNINDENT
.SH SYNTAX
.INDENT 0.0
.TP
.B The \fBcontainers.yaml\fP contains three main key/value mappings defining the following elements:
.INDENT 7.0
.IP \(bu 2
\fBcontainers\fP define container templates (somehow similar to VM templates)
.IP \(bu 2
\fBmodules\fP define additionnal modules to be applied to templates
.IP \(bu 2
\fBconfig\fP defines global configuration parameters relative to containers
.UNINDENT
.UNINDENT
.sp
We are now going to describe each of these turn by turn.
.SS Containers Templates
.sp
Elements in this section are relative to the \fBcontainers\fP entry of \fBcontainers.yaml\fP\&. It may contains configuration targetting containers by name. Each configuration is a key/value entry which key is the name of the image. In addition, a \fBdefault\fP template is applied to all containers. Leading to the following initial layout
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
containers:
  # Applies to all containers (by default)
  default:
    env:
      \- DEFAULT_VARIABLE=1
  # Will only apply to the \(aqbusybox\(aq container
  busybox:
    env:
      \- BUSYBOX_VARIABLE=2
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
In previous configuration, a container which name is \fBbusybox\fP should have the two templates trigerred, busybox \fIand\fP default. If the default configuration is to be disabled the \fB\-\-no\-defaults\fP option of \fBpcocc run\fP can be used. In addition, any other container lets say \fBcentos\fP would have a single environment variable from default.
.sp
Container templates support multi\-inheritance, it means that common configurations can be regrouped for convenience in a single arbitrary group. Consider the following file:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
containers:
  my_conf:
    env:
      \- DEFAULT_VARIABLE=1

  busybox:
    inherits:
      \- my_conf

  centos:
    inherits:
      \- my_conf
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
With previous configuration, both \fBcentos\fP and \fBbusybox\fP should have the parameters from \fBmy_conf\fP, in this example an environment variable \fBDEFAULT_VARIABLE\fP with a value of \fB1\fP\&. Note that multi\-inheritance (one to N, and transitive) is supported as long as it does not create dependency loops. Each entry is called a \fIcontainer template\fP and it gathers the following parameters:
.INDENT 0.0
.TP
\fBinherits\fP
(array of strings), for example, \fB["centos", "myconf"]\fP
.sp
Define a list of templates to by applied to the current template. A given template may inherit one or several templates either transitively or directly. Note that dependency loops are forbidded and lead to a configuration error. Inherited templates are merged in reverse order of resolution (depth first search), parent templates being applied before the intial template.
.UNINDENT
.INDENT 0.0
.TP
\fBenv\fP
(array of strings), for example, \fB["AA=8", "PATH", "re(OMPI.*)"]\fP
.sp
Insert environment variables in the target container. Either by directly reading the environment, using a variable name or a regular expresion, or by passing \fBKEY=VALUE\fP to progagate explicitly a given variable. This can be done using the following syntax:
.TS
center;
|l|l|.
_
T{
Syntax
T}	T{
Description
T}
_
T{
VAR=VALUE
T}	T{
Set variable \(aqVAR\(aq to value \(aqVALUE\(aq
T}
_
T{
VAR
T}	T{
Set variable \(aqVAR\(aq to current env value
T}
_
T{
re(REGEXPR)
T}	T{
Propagate all variables matching REGEXPR regular expression
T}
_
.TE
.UNINDENT
.INDENT 0.0
.TP
\fBpathprefix\fP
(array of strings), for example, \fB["PATH=/mybin", "LD_LIBRARY_PATH"]\fP
.sp
Prefix a PATH\-like variable in the target container, concatenating with ":". If only the variable name is provided, for example \fBPATH\fP it means that host \fBPATH\fP (as retrived from current environment) will be prefixed to the container default \fBPATH\fP\&. Otherwise, if a value is provided, it will be added to the target variable. For example, \fBLD_LIBRARY_PATH=/mylib/\fP adds \fB/mylib\fP at the beginning of the \fBLD_LIBRARY_PATH\fP inside the container. See the pcocc\-run(1) command for some example relative to prefixing.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Regular expression such as \fBre(OMPI.*)\fP are not supported (unlike in env). The same variable can be prefixed several times, for example to add various directories. Internally, pcocc uses ":" to concatenate paths as conventionally done in UNIX systems.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
\fBpathsuffix\fP
(array of strings), for example, \fB["PATH=/mybin", "LD_LIBRARY_PATH"]\fP
.sp
This has the same behavior than \fBpathprefix\fP except that it appends (instead of prefixing) to the given variables. See the pcocc\-run(1) command for some example relative to suffixing.
.TP
\fBmounts\fP
(key/values), for example \fBrootfs: {"source":"/", "destination":"/rootfs"}\fP
.INDENT 7.0
.INDENT 3.5
This is a key/value defining mountpoints inside the container according to the OCI mountpoint specifications \fI\%https://github.com/opencontainers/runtime\-spec/blob/master/config.md#mounts\fP\&. The souce is the only required field, if the other entries are not defined, it defaults to same destination and type is set to rbind in read\-write.
.sp
Each mount is defined as follows:
.INDENT 0.0
.TP
\fBsource\fP
(string)
The host path to export.
.TP
\fBdestination\fP
(string)
Path of where to export in the containers
.TP
\fBtype\fP
(string)
Type of mount for example \fBrbind\fP
.TP
\fBoptions\fP
(array of strings)
Options to be passed to mount (for example \fB["ro"]\fP).
.UNINDENT
.sp
For example if you want to define two mounts:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
containers:
  my_conf:
    mounts:
        # Mounts /compute at /compute in container
        # Mount is rbind in read\-write
        compute:
            source: /compute/
        # Mount /data at /rodata in read\-only
        data:
            source: /data/
            destination: /rodata/
            options:
                \- ro
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.TP
\fBns\fP
.INDENT 7.0
.INDENT 3.5
(array of strings), for example \fB["mount", "uts"]\fP
.sp
This is the list of namespaces to be enabled inside the containers.
.sp
The following namespaces are defined (following Linux namespaces):
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIuts\fP : Hostname and NIS domain name namespaces
.IP \(bu 2
\fIpid\fP : Process IDs namespaces
.IP \(bu 2
\fIipc\fP : System V IPC, POSIX message queues namespace
.IP \(bu 2
\fImount\fP : Mount points namespace
.IP \(bu 2
\fInetwork\fP : Network namespace
.UNINDENT
.UNINDENT
.UNINDENT
.sp
See \fBman namespaces\fP for more details.
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Some program may not operate correctly if you isolate your container too much, for example MPI generally operates with only the \fBmount\fP namespace as it requires IPC and Network access. A recommended default is \fB["mount", "uts"]\fP
.UNINDENT
.UNINDENT
.TP
\fBhooks\fP
(key/value) example \fB{"prestart":{"path": "/usr/bin/myhook"}\fP
.sp
This entry defines the OCI hooks as implemented in the OCI standard \fI\%https://github.com/opencontainers/runtime\-spec/blob/master/config.md#posix\-platform\-hooks\fP\&.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
OCI hooks can be enabled using the configuration see \fI\%enable_oci_hooks\fP\&.
.UNINDENT
.UNINDENT
.sp
Such hooks are run at various steps of the container execution, including:
.INDENT 7.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
\fIprestart\fP: just before the container runs
.IP \(bu 2
\fIpoststart\fP: just after the container started
.IP \(bu 2
\fIpoststop\fP: just after the container stopped
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Each hook is a key/value entry in a list indexed by one of the aforementionned key. (See the example below).
.sp
Each hook is defined as follows (only \fBpath\fP is required):
.INDENT 7.0
.INDENT 3.5
\fBpath\fP
(string), for example \fB/bin/hook\fP
.sp
The absolulte path of the command to be run
.sp
\fBargs\fP
(array of strings), for example \fB["\-t", "\-u"]\fP
.sp
Arguments to be passed to the \fBpath\fP program.
.sp
\fBenv\fP
(array of strings), for example \fB["MYVAR=8"]\fP
.sp
List of environment variables to be passed to the command.
.sp
\fBtimeout\fP
(integer), for exampe \fB25\fP
.sp
Max execution time in seconds for the hook
.UNINDENT
.UNINDENT
.sp
The following example illustrates the use of hooks:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
containers:
  my_conf:
    hooks:
        prestart:
            \- path: /bin/echo
              args: "prestart1"
            \- path: /bin/echo
              args: "prestart2"
        poststart:
            \- path: /bin/echo
              args: "poststart"
        poststop:
            \- path: /bin/container_stopped
              args: "\-u"
              env:
                \- STOPPED_CONT=1
              timeout: 32
.ft P
.fi
.UNINDENT
.UNINDENT
.TP
\fBgenerator\fP
(array of strings), for example \fB["gen_mounts \-t", "inject_my_home"]\fP
.sp
Use a command to generate mounts dynamically for this configuration. Parameters are parsed from the standard output of the called program with the following syntax:
.TS
center;
|l|l|.
_
T{
Keyworkd
T}	T{
Description
T}
_
T{
ENV
T}	T{
Export an environment variable (same as \fI\%env\fP:)
T}
_
T{
PATHPREFIX
T}	T{
Prefix an environment variable (same as \fI\%pathprefix\fP)
T}
_
T{
PATHSUFFIX
T}	T{
Suffix an environment variable (same as \fI\%pathsuffix\fP)
T}
_
T{
MOUNT
T}	T{
src[:target] mount a path in a container with an optionnal target
T}
_
T{
MODULE
T}	T{
Link to a runtime module (see \fI\%runtime templates\fP)
T}
_
.TE
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
Pcocc will append two parameters to the generator command:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
the path to the config.json for this container
.IP \(bu 2
the path to the rootfs of the container
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Such as for example \fBmygenerator \-t \(aqgenmounts\(aq\fP is invoked as:
\fBmygenerator \-t \(aqgenmounts\(aq /tmp/xxxx/config.json /tmp/xxxx/rootfs/\fP
.UNINDENT
.UNINDENT
.sp
Sample generator definition:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
containers:
    generator:
        # Will invoke the command and parse its output
        \- "mygenerator \-t \(aqgenmounts\(aq"
        \- "mygenerator \-t \(aqgenenv\(aq"
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Sample generator output:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# Export MYVAR
ENV MYVAR
# Mount /mydata to /contdata
MOUNT /mydata:/contdata
# Mount /compute to /compute
MOUNT /compute
# Add /compute/lib in LD_LIBRARY_PATH
PATHPREFIX LD_LIBRARY_PATH=/compute/lib/
# Activate the MPI module
MODULE mpi
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Runtime Templates
.sp
Elements in this section are relative to the \fBmodules\fP entry of \fBcontainers.yaml\fP\&. Such configurations are strictly identical in structure to the ones of \fI\%container templates\fP, they only differ in the way they are applied to the container. Indeed, unlike container configurations which are applied by name, these configurations can be enabled through the module command switch of the run command. This allows a more dynamic configuration of a given run on a per\-invocation basis, instead of on a per\-image one. Conside the following configuration:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
modules:
    hydro:
        generator:
            \- "injecthydro"
    exporta:
        env:
            \- A=1337
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Here we defined two configurations, \fBhydro\fP and \fBexporta\fP\&. Note that such configurations also support inheritance. These templates can then be applied by two means:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP \(bu 2
Passing the \-M/\-\-module flag to the pcocc\-run(1) command.
.IP \(bu 2
Using the \fIMODULE\fP command from generators in templates
.UNINDENT
.UNINDENT
.UNINDENT
.sp
For example to invoke the \fBcentos\fP container using these templates:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Pass each template turn by turn
pcocc run \-I centos \-M hydro \-M exporta
# Use comma separated lists
pcocc run \-I centos \-M hydro,exporta
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Container Config
.sp
Elements in this section are relative to the \fBconfig\fP entry of \fBcontainers.yaml\fP\&.
It may contains the following \fIoptionnal\fP entries:
.INDENT 0.0
.TP
\fBdocker_path\fP
(string), for example, \fB"/opt/docker"\fP
.sp
A path to the docker command line tools installation on the system. Note that Docker is available in the form of static binaries here : \fI\%https://download.docker.com/linux/static/stable/\fP\&. One may download and deploy these binaries on the system before pointing \fBdocker_path\fP to the corresponding path to sucessfully install docker tools for pcocc as far as the client\-side aspects are concerned.
.TP
\fBdocker_pod\fP
(string), for example, \fB"docker\-pod"\fP
.sp
Name of the VM template to use as docker pod when allocating docker vms with \fBpcocc docker alloc\fP\&. This VM should host the pcocc agent and a docker daemon.
.TP
\fBdocker_mounts\fP
(array of strings), for example, \fB["/compute", "/userhomes"]\fP
.sp
A list of docker mounts to make visible to the docker daemon running inside the virtual machine. Due to implementation constraints some paths cannot be added as they are already present in the target file\-system.
.UNINDENT
.INDENT 0.0
.TP
\fBenable_oci_hooks\fP
(boolean), for example, \fBTrue\fP
.sp
Whether OCI hooks should be enabled in pcocc as defined in the OCI specifications : \fI\%https://github.com/opencontainers/runtime\-spec/blob/master/config.md#posix\-platform\-hooks\fP\&. This setting defaults to \fBTrue\fP\&.
.TP
\fBuse_squashfs\fP
(boolean), for example, \fBTrue\fP
.sp
Enable squashfs support in pcocc, avoiding full image extraction in the file\-system. Note that not enabling this feature impact on features, it provides performance gains when manipulating images (importing, deleting, ...). This setting defaults to \fBFalse\fP\&.
.sp
\fBWARNING:\fP
.INDENT 7.0
.INDENT 3.5
In order to enable squashfs you need to provide dependencies on the system. In particular \fBsquashfs\-tools\fP and \fBsquashfuse\fP which is used to mount images.
.UNINDENT
.UNINDENT
.TP
\fBsquashfs_image_mountpoints\fP
(advanced)
(array of strings), for example, \fB["/compute/", "/userhomes/"]\fP
.sp
A list of paths to be inserted in the squashfs images to optimize launch time. Indeed, as squashfs images are read\-only, pcocc relies on a "reverse mount" technique which is less optimal when iserting mounts in populated directories. Pre\-creating directories which are known to exist enables potential optimization a launch time.
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
If the path ends with a "/" it creates a directory, otherwise it create an empty file.
.UNINDENT
.UNINDENT
.TP
\fBdocker_test_path\fP
(advanced)
A path to a docker\-related path \fIinside\fP the docker_pod vm to watch for docker strartup.
.TP
\fBdocker_use_ip_address\fP
(advanced)
Instruct pcocc not to use domain names to contact the docker enabled VM but instead to rely on IP adresses.
.UNINDENT
.SH SAMPLE CONFIGURATION FILE
.sp
This is a sample template definition. Please note that indentation is significant in YAML:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
config:
    # Path to a docker\-cli as imported for example from static
    # binaries https://download.docker.com/linux/static/stable/
    docker_path: /opt/docker\-cli/
    # If the connection to Docker should us an IP instead of a hostname
    docker_use_ip_address: true
    # Name of the docker VM pod image
    docker_pod: docker\-pod
    # List of mountpoints to expose inside the Docker environment
    # they SHOULD not conflict with existing directories or files
    docker_mounts:
        # A mountpoint is {src: XX, dest: XX} and dest can
        # be ommited it then implies src=dest
        \- src: /usr/
          dest: /test/usr
        \- src: /mydir
    # Define if pcocc has to interpret OCI hooks in container configuration files
    # see https://github.com/opencontainers/runtime\-spec/blob/master/config.md#posix\-platform\-hooks
    enable_oci_hooks: false
    # Define if pcocc has to use squashfs images or rootfs images
    use_squashfs: true
    # Some files are known to be systematically mounted in containers
    # in order to speedup launch time it is possible to pre\-populate them
    # when generating the squashfs images. In this case, empty files / dirs
    # are created, avoiding possibly expensive mounts later on
    # NOTE : if the path ends with a "/" it will create a directory
    squashfs_image_mountpoints:
        \- "/ect/passwd"
        \- "/etc/resolv.conf"
        # \- "/sharedworkspace/"


# Per container environment (when being run by pcocc)
containers:
    # The "default" key applies to all containers
    example:
      mounts: # What is mounted inside the container
          example: # Follows OCI mountpoint semantics
            source: "/example"
            destination: "/example"
            type: "bind"
      ns: # Which namespaces to activate
          \- "uts"
          \- "mount"
      env:
          \- EXPORT_THIS_VARIABLE=1
          \- PWD
      hooks:
          # OCI hooks
          # see https://github.com/opencontainers/runtime\-spec/blob/master/config.md#posix\-platform\-hooks
          prestart:
              # Before starting the command
              \- path: /usr/bin/ls
                env:
                    \- AA=8
                    \- BB=azery
                args:
                    \- \-la
                timeout: 120
          #poststart:
              # Same layout
          #poststop:
              # Same layout

# Configuration for modules (\-M flag of pcocc run)
# content is similar to container config and overlap
# with the initial container config except that inheritance is supported
# \-M flags can be put multiple times or comma separated
# for example \-M nvidia,pmi is equivalent to \-M nvidia \-M pmi
modules:
    pmienv:
        # What is needed to inject the host PMI from SLURM
        env:
            \- \(aqre(SLURM*)\(aq
            \- \(aqre(PMI*)\(aq
        mounts:
            libpmi2::ref:\(gapcocc\-template(1)<template>\(ga
                source: /usr/lib64/libpmi2.so.0
                destination: /pcocc/lib/pmi/libpmi2.so.0
            libpmi:
                source: /usr/lib64/libpmi.so.0
                destination: /pcocc/lib/pmi/libpmi.so.0
            libslurm:
                source: /usr/lib64/libslurm.so.32
                destination: /pcocc/lib/pmi/libslurm.so.32
        pathprefix:
            \- LD_LIBRARY_PATH=/pcocc/lib/pmi/

    verbs:
        # What is needed to inject host IB configuration
        mounts:
            verbsconfdir:
                source: "/etc/libibverbs.d"
            verbs_rdmacm:
                source: "/usr/lib64/librdmacm.so.1.0.0"
                destination: "/pcocc/lib/verbs/librdmacm.so.1"
            verbs_mlx5:
                source: "/usr/lib64/libmlx5.so.1.0.0"
                destination: "/pcocc/lib/verbs/libmlx5\-rdmav2.so"
            verbs_mlx4:
                source: "/usr/lib64/libmlx4\-rdmav2.so"
                destination: "/pcocc/lib/verbs/libmlx4\-rdmav2.so"
            verbs:
                source: "/usr/lib64/libibverbs.so.1.0.0"
                destination: "/pcocc/lib/verbs/libibverbs.so.1"
            libnl:
                # This is a dependency lib to IBVERBS
                source: "/lib64/libnl.so.1"
                destination: "/pcocc/lib/verbs/libnl.so.1"
            devices:
                source: /dev/infiniband/
                options: ["dev"]
        pathprefix:
            \- LD_LIBRARY_PATH=/pcocc/lib/verbs/

    pmi:
        inherits:
            \- "pmienv"
            \- "verbs"
        env:
            \- "OMPI_MCA_btl_openib_allow_ib=1"

#
# In this last example we present command\-based configurations
#
# pcocc can process the output of a program to generate a configuration
# on the fly with a line\-based syntax:
#
# MOUNT [SRC](:[DEST])
# ENV [VAR] or [VAR=B] or re(XX.*)
# PATHPREFIX [VAR] or [VAR=X]
# PATHSUFFIX [VAR] or [VAR=X]
# MODULE [MOD]
#
# Each command is passed the following extra arguments:
# [PATH TO config.json] [PATH to rootfs]
#
    nvidia:
        generator:
            \- nvidia_container_list
.ft P
.fi
.UNINDENT
.UNINDENT
.SH SEE ALSO
.sp
pcocc\-run(1), pcocc\-template(1), pcocc\-image(1), pcocc\-batch(1), pcocc\-alloc(1), pcocc\-save(1), pcocc\-resources.yaml(5), pcocc\-networks.yaml(5), pcocc\-newvm\-tutorial(7)
.SH AUTHOR
François Diakhaté
.SH COPYRIGHT
2017
.\" Generated by docutils manpage writer.
.
